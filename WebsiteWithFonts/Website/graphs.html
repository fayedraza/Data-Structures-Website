<!doctype html>
<html lang="en">
  
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
    <link rel="stylesheet" href="bootstrap.min.css"> 
    <link rel="stylesheet" href="styles.css">

    <title> Graphs </title>

  
  </head>
  <nav style="height: 100px;padding:0" id="header-nav" class="navbar navbar-default">

    <div class="container">
      <nav class="navbar navbar-expand-lg navbar-light bg-light">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavDropdown">
          <ul class="navbar-nav">
            <li class="nav-item">
              <a class="nav-link" href="frontpage.html">Home</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="bigO.html">Big O </a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="searchandsorting.html">Searching and Sorting Methods</a>
              </li>
            <li class="nav-item">
              <a class="nav-link" href="arrays.html">  Arrays  </a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="LinkedList.html">  Linked Lists  </a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="StacksAndQueues.html">Stacks and Queues</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="trees.html">Trees</a>
              </li>
              <li class="nav-item">
                <a class="nav-link" href="hashtable.html">Hash Tables</a>
              </li>
            <li class="nav-item active">
              <a class="nav-link" href="#">Graphs  <span class="sr-only">(current)</span> </a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="other.html"> Other Topics </a>
            </li>
          </ul> 
        </div>
      </nav>
      
    </div>
    </nav>

    
<body style="background-color: rgb(223, 217, 217);">
    <h1 id="home">Graphs</h1>

    <h2>What is a Graph? </h2>

    <p class="text">Graphs are a data strucutres where there are many vertices connected with each other. Think about social meida 
        websites like Facebook or Linkedln where there are a network between friends or family has been made.
    </p>
    
    <p class = "text">  Here is an example of a graph. In terms of Facebook, you can think like A is friends with B 
        or an example in Linkedln is, E is 1 connection away from B.
    </p>
      
    <img class = "image" src="https://user-images.githubusercontent.com/42160652/85974597-e7eb8080-b9a3-11ea-9eda-688223928235.jpeg
      " width="600" height="640">

      <p class = "text"> So there here are some types of grpahs. One is a directed graph: a graph with arrows and has strict connection such as,
          A can go to B, but B can't got to A. Think about how in Instagram, you follow Hugh Jackman but he does not follow you back. Another type is an undirected graph: a graph where two vertices know each other back an forth. 
          For instance, you follow your friend and your friend follows you back.
    </p>
      
    <img class = "image" src="https://user-images.githubusercontent.com/42160652/85974837-84ae1e00-b9a4-11ea-9d04-c43afc98d5ff.jpeg
      " width="600" height="640">

    <p class = "text"> So there here are some types of grpahs. One is a directed graph: a graph with arrows and has strict connection such as,
        A can go to B, but B can't got to A. Think about how in Instagram, you follow Hugh Jackman but he does not follow you back. Another type is an undirected graph: a graph where two vertices know each other back an forth. 
        For instance, you follow your friend and your friend follows you back.
  </p>
    
  <img class = "image" src="https://user-images.githubusercontent.com/42160652/85974837-84ae1e00-b9a4-11ea-9d04-c43afc98d5ff.jpeg
    " width="600" height="640">

    <p class = "text"> We are go over simple graphs: graphs with no self loop or has no multiple edges. Here is an example of graphs
        that are not simple. While they are useful in certain situations, they are not necessary to know.
    </p>
      
    <img class = "image" src="https://user-images.githubusercontent.com/42160652/85976942-9d6d0280-b9a9-11ea-85c4-e247b6a60eaa.jpeg
      " width="600" height="640">

      <p class = "text"> Cyclic graphs are graphs with a cycle and acyclic graphs are graphs without a cycle.
    </p>
      
    <img class = "image" src="https://user-images.githubusercontent.com/42160652/85981698-a6ae9d00-b9b2-11ea-8648-e7dfa6f11a20.jpeg
      " width="600" height="640">

    <p class = "text"> Graphs can also have weights. This is called a weighted graph. 
  </p>
    
  <img class = "image" src="https://user-images.githubusercontent.com/42160652/85975157-4fee9680-b9a5-11ea-8c46-3a0939107320.jpeg
    " width="600" height="640">

    <p class = "text"> Here are two ways we can represent a graph: an adjency matrix (like a 2D array) and an adjency linked list (similar to a hash table).
    </p>
      
    <img class = "image" src="https://user-images.githubusercontent.com/42160652/85975370-ddca8180-b9a5-11ea-8335-925e2774a082.jpeg
      " width="600" height="640">

    <p class = "text"> As you can see we reprsented agn undirected graph in an adjency matrix. Basically, A to B (0 to 1) and B to A (1 to 0) will be filled in 
        the adjency matrix with T since A and B knows each other. On the image on the right, since A knows B but not the other way, only (0,1) will be filled with
        T. Also, when plotting, we will first start with 0 on the x-axis then 1 on the y-axis.
    </p>
      
    <div class="flex-container">
        <div><img src="https://user-images.githubusercontent.com/42160652/85975562-6c3f0300-b9a6-11ea-9016-d5ad7fbce01a.jpeg" width="420" height="440"></div>
        <div><img src= "https://user-images.githubusercontent.com/42160652/85975567-706b2080-b9a6-11ea-9e5f-ac8e6ed8471a.jpeg" width="420" height="440"> </div>
      </div>

      <p class = "text"> With weighted graphs, we will replace T with the weight to represent the relationship.
    </p>
      
    <img class = "image" src="https://user-images.githubusercontent.com/42160652/85976279-313dcf00-b9a8-11ea-9048-abcbcb31dbb2.jpeg
      " width="600" height="640">

      <p class = "text"> The adjency linked list has each vertex holding all of their neighbors. - represents the neighor relationship
          in directed and -> remember the relationship in undirected graph. 
    </p>
      
    <div class="flex-container">
        <div><img src="https://user-images.githubusercontent.com/42160652/85976355-66e2b800-b9a8-11ea-9a08-1882c327deb2.jpeg" width="420" height="440"></div>
        <div><img src= "https://user-images.githubusercontent.com/42160652/85976350-63e7c780-b9a8-11ea-9e90-c60ff2a73714.jpeg" width="420" height="440"> </div>
      </div>

      <p class = "text"> Graphs can be seperated apart. They could have no connections at all. These are called islands.
    </p>
      
    <img class = "image" src="https://user-images.githubusercontent.com/42160652/85977487-b1653400-b9aa-11ea-9280-5dc06d6e2c79.jpeg
      " width="600" height="640">

      <h3>Coding Graphs in Java</h3>


      <p class = "text"> Basically we can make an adjecny linked list. Each element is a vertex object where it holds the name of a vertex and its list 
        of neighbors (neighbors are reprsented in neighbor objects). You can basically make an array of holding vertex objects and in each element
        it will hold the vertex name and its neighbors. 
   </p>
     
   <img class = "image" src="https://user-images.githubusercontent.com/42160652/86029268-eef4ac00-ba00-11ea-9acb-2fbbd36a3410.jpeg
     " width="600" height="640">

   <h2>Traversing a Graph: Depth First Search (DFS) </h2>


   <p class = "text">So how can we traverse through a graph, there are two popular types of traversals. We will first go through depth 
       first search. We start at the new node and see if there is children then we call depth first search on them. Once done we go onto
       the next child and so on till we go through all of the nodes. We will start with an array initialized with all values as false.
       Each index the vertex matches with the boolean value in the array.
</p>
  
<img class = "image" src="https://user-images.githubusercontent.com/42160652/85978801-787a8e80-b9ad-11ea-88d1-0b495dea5cee.jpeg
  " width="600" height="640">

  <p class = "text">First, we will visit A and turn it to True to represent we have visited it.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85978604-0c982600-b9ad-11ea-96ca-5bbae75995e4.jpeg
" width="600" height="640">

<p class = "text">Then we visit B and turn it to True. Also we will now call depth first search on its children. We first call it
    on C since C alphabetically come first.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85979021-c7282880-b9ad-11ea-9d8c-229ab8ad0b43.jpeg
" width="600" height="640">

<p class = "text"> C gets its boolean value turned to true. but it has no children on its own so we are done from here. Now off to
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85979234-140bff00-b9ae-11ea-9f4b-01b5c40e5902.jpeg
" width="600" height="640">

<p class = "text"> Then D gets it boolean value turned to true. Now lets call DFS on D's children.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85979021-c7282880-b9ad-11ea-9d8c-229ab8ad0b43.jpeg
" width="600" height="640">

<p class = "text"> For all of D's children we just needed to mark it true and no need to call more DFS since there are no other
    children.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85980055-a5c83c00-b9af-11ea-83f9-0c830ca5492a.jpeg
" width="600" height="640">

<p class = "text"> In the case, there was an Island we would have to restart. For instance, we would have to restart at H after being 
    done executing the first island. Now try to implement DFS in Java.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85980265-0eafb400-b9b0-11ea-809e-3e4393d54b1a.jpeg
" width="600" height="640">

<p class = "text"> Java implementation of DFS
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/86029160-d08eb080-ba00-11ea-84f3-052c39ddb674.jpeg
" width="600" height="640">

<h2>Traversing a Graph: Breadth First Search (BFS) </h2>

<p class = "text">Another type of traversal is, Breadth First Search. Using a queue, we add the first vertex and then add the 
    children of that vertex to the queue. Then we will pop out a vertex of the queue and do bfs with that. We keep on doing it till
    the queue is empty.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85980690-de1c4a00-b9b0-11ea-9f67-172b59f6dc72.jpeg
" width="600" height="640">

<p class = "text">Then we pop B out and mark its boolean value to true. Also, we add B's children: C and D.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85980969-5c78ec00-b9b1-11ea-9d2e-903dc95635e4.jpeg
" width="600" height="640">

<p class = "text">Then we pop out C and since C does not have and children, we just mark it true and pop out the next one. We add and E,F, and 
    G and call BFS on each of them. The queue becomes empty and we can stop Breadth First Search. Now try to implement BFS.
</p>

<p class = "text"> Java implementation of BFS
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/86029085-b654d280-ba00-11ea-8110-1f52bfab18d5.jpeg
" width="600" height="640">

<h2> Applications of Graphs: Topological Sort (DFS) </h2>

<p class = "text">Suppose we wanted to complete a bunch of tasks in order of precedence. We can do that in a process called Topological Sort 
    where we assign numbers in order of precedence (topological numbers).
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85980969-5c78ec00-b9b1-11ea-9d2e-903dc95635e4.jpeg
" width="600" height="640">

<p class = "text"> We could start at A and number at zero and label B, 1 and C, 2. But here is the problem? What if we start at C? We can't 
    number it zero because that does not have higher precedence.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85982461-dc07ba80-b9b3-11ea-818f-72194e84d496.jpeg
" width="600" height="640">

<p class = "text"> We could start at 4 on C and then backtrack and declare 3.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85983122-f3937300-b9b4-11ea-9034-2ce01b969835.jpeg
" width="600" height="640">

<p class = "text"> Then declare 2 on E. Backtrack to 1 and then 0.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85983214-1aea4000-b9b5-11ea-81c4-bade582879ea.jpeg
" width="600" height="640">

<p class = "text"> This is how we would topological sort, if we start at A. It seem pretty easy if you get the previous example. Now try 
  to implement DFS Topsort on your own.
</p>

<div class="flex-container">
  <div><img src="https://user-images.githubusercontent.com/42160652/85983323-55ec7380-b9b5-11ea-964e-0482d1808c43.jpeg" width="420" height="440"></div>
  <div><img src= "https://user-images.githubusercontent.com/42160652/85983328-584ecd80-b9b5-11ea-8b46-42b90d8eb97f.jpeg" width="420" height="440"> </div>
</div>
<div class="flex-container">
    <div><img src="https://user-images.githubusercontent.com/42160652/85983334-597ffa80-b9b5-11ea-8124-09382dcd4507.jpeg" width="420" height="440"></div>
    <div><img src= "https://user-images.githubusercontent.com/42160652/85983351-600e7200-b9b5-11ea-9e29-2313833a8f9d.jpeg" width="420" height="440"> </div>
  </div>

  <p class = "text">  Java implementation of DFS Topsort.
  </p>
  
  <img class = "image" src="https://user-images.githubusercontent.com/42160652/86028896-7b529f00-ba00-11ea-96c7-99dfeb4f2671.jpeg
  " width="600" height="640">

  <h2> Applications of Graphs: Topological Sort (BFS) </h2>

  <p class = "text">  We will first add all of the vertices that already has an index of zero (because of this we don't even need a
    driver for bfs).
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85983916-56d1d500-b9b6-11ea-8f7d-e9561a86b947.jpeg
" width="600" height="640">

<p class = "text">  We will first calculate all of the indegrees. Indegrees of a vertex are determined by how many vertices point to 
    that vertex. We also will add them to the final sequence. 
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85983984-6f41ef80-b9b6-11ea-85fb-487fc5821483.jpeg
" width="600" height="640">

<p class = "text">  Now we popped one out and for the neighbors of that we will decrease its value. For instance, A's neighbors, B
    and D, will be decreased by 1. Since both of them are now zero, we will add it to the queue and the final sequence array.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85983984-6f41ef80-b9b6-11ea-85fb-487fc5821483.jpeg
" width="600" height="640">

<p class = "text">  Now we popped one out and for the neighbors of that we will decrease its value. For instance, A's neighbors, B
    and D, will be decreased by 1. Since both of them are now zero, we will add it to the queue and the final sequence array. F's neighbor
    E will be decreased by 1 but it is still not zero so we can not add it to the queue and the final sequence. 
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85984660-79b0b900-b9b7-11ea-9633-3f46da289096.jpeg
" width="600" height="640">

<p class = "text"> C and E have become zero so we can add them to the queue and final array. Both C and E have no children so 
    we are done. Now try to implement bfs topsort on your own.
</p>

<div class="flex-container">
  <div><img src="https://user-images.githubusercontent.com/42160652/85984739-9947e180-b9b7-11ea-8e10-f8c616884023.jpeg" width="420" height="440"></div>
  <div><img src= "https://user-images.githubusercontent.com/42160652/85984752-9cdb6880-b9b7-11ea-8260-81f55d914be7.jpeg" width="420" height="440"> </div>
</div>

<p class = "text">  Java implementation of BFS Topsort.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/86028738-45151f80-ba00-11ea-9763-9af306768fef.jpeg
" width="600" height="640">

<h2> Dijkastra's Shortest Algorithm </h2>

<p>Dijkastra's shortest algorithm can be used to find the shortest path. It is responsible for many applications such as, Google Maps.
    It was founded by computer scientist Edsger W. Dijkstra in 1956.
</p>

<p class = "text">  Suppose we wanted to find the shortest path from A to C. Then we will first add A on done. 
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85986064-a4037600-b9b9-11ea-9333-755c6841f819.jpeg
" width="600" height="640">

<p class = "text">  Then we list all of the lengths from A to ... . If it does not exist with put infinity. We circled the shortest
    length which will be 5 meaning we are done with B and that is the shortest path.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85986068-a534a300-b9b9-11ea-8d43-86685c7f0361.jpeg
" width="600" height="640">

<p class = "text">  Then we list all of the lengths from B to ... excluding B since we already are done (put a squigly line to show that
    we are done). Then we add 105 as we combined the length of path from B to C (100) plus the previous shortest path (5) and it will sum
    up to 105. D is still 10 as a direct path between B to D does not exist. D (10) is our shortest path. 
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85986068-a534a300-b9b9-11ea-8d43-86685c7f0361.jpeg
" width="600" height="640">

<p class = "text">  Now we are at D. Since the path from D to C is 6 and the last shortest was 10 so, 6+10=16. 16 is less than 105,
    so 105 will be replcaed with 16. The shortest path is 16.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85986068-a534a300-b9b9-11ea-8d43-86685c7f0361.jpeg
" width="600" height="640">

<p class = "text">  Now we are at D. Since the path from D to C is 6 and the last shortest was 10 so, 6+10=16. 16 is less than 105,
    so 105 will be replcaed with 16. The shortest path is 16.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85987071-280a2d80-b9bb-11ea-9543-1bf70a728752.jpeg
" width="600" height="640">

<p class = "text"> Now find the shortest path from A to F.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85987162-47a15600-b9bb-11ea-90db-289e22ae9b3e.jpeg
" width="600" height="640">

<p class = "text">  Answer with explanation is below.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85987165-48d28300-b9bb-11ea-904f-e783a4fa709d.jpeg
" width="600" height="640">

<p class = "text"> Implemenet Shortest Path between two verticies in Java 
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85987280-715a7d00-b9bb-11ea-9862-cd024752a68a.jpeg
" width="600" height="640">

<p class = "text">  Answer with explanation is below.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85987284-728baa00-b9bb-11ea-8a89-dd2b338b07e7.jpeg
" width="600" height="640">

<h2>Big O of Graphs</h2>


<p class = "text">  This is the space complexity of adjacency matrix and adjacency linked list.  (edit)
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85987549-be3e5380-b9bb-11ea-97c1-5bb04248a5fa.jpeg
" width="600" height="640">

<p class = "text"> Runtime of BFS and DFS traversals and Topsort. BFS and DFS have the same runtime which is why overall not one 
  is better than the other, but in certain problems one can be better than the other.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85987543-bbdbf980-b9bb-11ea-8497-268021c409f7.jpeg
" width="600" height="640">

<p class = "text"> Runtime of Dijkastra's Method. It is determined by four functions: add to fringe, pick minimum, check old distance vs new distance, and
    update distance. So here are all the scenarios of what we used as a fringe and how it affects
    the four functions.
</p>

<img class = "image" src="https://user-images.githubusercontent.com/42160652/85987547-bd0d2680-b9bb-11ea-9831-b866dd85c324.jpeg
" width="600" height="640">
<!-- Optional JavaScript -->
 <!-- jQuery first, then Popper.js, then Bootstrap JS -->
 <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
 <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
 <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js" integrity="sha384-OgVRvuATP1z7JjHLkuOU7Xw704+h835Lr+6QL9UvYjZE3Ipu6Tp75j7Bh/kR0JKI" crossorigin="anonymous"></script>
</body>
</html>